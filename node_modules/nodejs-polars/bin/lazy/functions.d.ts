import { Expr } from "./expr";
import { Series } from "../series/series";
import { DataFrame } from "../dataframe";
import { ExprOrString } from "../utils";
/**
 * __A column in a DataFrame.__
 * Can be used to select:
 *   * a single column by name
 *   * all columns by using a wildcard `"*"`
 *   * column by regular expression if the regex starts with `^` and ends with `$`
 * @param col
 * @example
 * ```
 * >>> df = pl.DataFrame({
 * >>> "ham": [1, 2, 3],
 * >>> "hamburger": [11, 22, 33],
 * >>> "foo": [3, 2, 1]})
 * >>> df.select(col("foo"))
 * shape: (3, 1)
 * ╭─────╮
 * │ foo │
 * │ --- │
 * │ i64 │
 * ╞═════╡
 * │ 3   │
 * ├╌╌╌╌╌┤
 * │ 2   │
 * ├╌╌╌╌╌┤
 * │ 1   │
 * ╰─────╯
 * >>> df.select(col("*"))
 * shape: (3, 3)
 * ╭─────┬───────────┬─────╮
 * │ ham ┆ hamburger ┆ foo │
 * │ --- ┆ ---       ┆ --- │
 * │ i64 ┆ i64       ┆ i64 │
 * ╞═════╪═══════════╪═════╡
 * │ 1   ┆ 11        ┆ 3   │
 * ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
 * │ 2   ┆ 22        ┆ 2   │
 * ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
 * │ 3   ┆ 33        ┆ 1   │
 * ╰─────┴───────────┴─────╯
 * >>> df.select(col("^ham.*$"))
 * shape: (3, 2)
 * ╭─────┬───────────╮
 * │ ham ┆ hamburger │
 * │ --- ┆ ---       │
 * │ i64 ┆ i64       │
 * ╞═════╪═══════════╡
 * │ 1   ┆ 11        │
 * ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
 * │ 2   ┆ 22        │
 * ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
 * │ 3   ┆ 33        │
 * ╰─────┴───────────╯
 * >>> df.select(col("*").exclude("ham"))
 * shape: (3, 2)
 * ╭───────────┬─────╮
 * │ hamburger ┆ foo │
 * │ ---       ┆ --- │
 * │ i64       ┆ i64 │
 * ╞═══════════╪═════╡
 * │ 11        ┆ 3   │
 * ├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
 * │ 22        ┆ 2   │
 * ├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
 * │ 33        ┆ 1   │
 * ╰───────────┴─────╯
 * >>> df.select(col(["hamburger", "foo"])
 * shape: (3, 2)
 * ╭───────────┬─────╮
 * │ hamburger ┆ foo │
 * │ ---       ┆ --- │
 * │ i64       ┆ i64 │
 * ╞═══════════╪═════╡
 * │ 11        ┆ 3   │
 * ├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
 * │ 22        ┆ 2   │
 * ├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
 * │ 33        ┆ 1   │
 * ╰───────────┴─────╯
 * >>> df.select(col(pl.Series(["hamburger", "foo"]))
 * shape: (3, 2)
 * ╭───────────┬─────╮
 * │ hamburger ┆ foo │
 * │ ---       ┆ --- │
 * │ i64       ┆ i64 │
 * ╞═══════════╪═════╡
 * │ 11        ┆ 3   │
 * ├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
 * │ 22        ┆ 2   │
 * ├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
 * │ 33        ┆ 1   │
 * ╰───────────┴─────╯
 * ```
 */
export declare function col(col: string | string[] | Series): Expr;
export declare function cols(col: string | string[]): Expr;
export declare function cols(col: string, ...cols: string[]): Expr;
export declare function lit(value: any): Expr;
/**
 * __Create a range expression.__
 * ___
 *
 * This can be used in a `select`, `with_column` etc.
 * Be sure that the range size is equal to the DataFrame you are collecting.
 * @param low - Lower bound of range.
 * @param high - Upper bound of range.
 * @param step - Step size of the range
 * @param eager - If eager evaluation is `true`, a Series is returned instead of an Expr
 * @example
 * ```
 * >>> df.lazy()
 * >>>   .filter(pl.col("foo").lt(pl.arange(0, 100)))
 * >>>   .collect()
 * ```
 */
export declare function arange<T>(opts: {
    low: any;
    high: any;
    step: number;
    eager: boolean;
}): any;
export declare function arange(low: any, high?: any, step?: number, eager?: true): Series;
export declare function arange(low: any, high?: any, step?: number, eager?: false): Expr;
/**  Alias for `pl.col("*")` */
export declare function all(): Expr;
/**
 * __Find the indexes that would sort the columns.__
 * ___
 * Argsort by multiple columns. The first column will be used for the ordering.
 * If there are duplicates in the first column, the second column will be used to determine the ordering
 * and so on.
 */
export declare function argSortBy(exprs: Expr[] | string[], reverse?: boolean | boolean[]): Expr;
/** Alias for mean. @see {@link mean} */
export declare function avg(column: string): Expr;
export declare function avg(column: Series): number;
/**
 * Concat the arrays in a Series dtype List in linear time.
 * @param exprs Columns to concat into a List Series
 */
export declare function concatList(exprs: ExprOrString[]): Expr;
export declare function concatList(expr: ExprOrString, ...exprs: ExprOrString[]): Expr;
export declare function concatList(expr: ExprOrString, expr2: ExprOrString, ...exprs: ExprOrString[]): Expr;
/** Concat Utf8 Series in linear time. Non utf8 columns are cast to utf8. */
export declare function concatString(opts: {
    exprs: ExprOrString[];
    sep: string;
}): any;
export declare function concatString(exprs: ExprOrString[], sep?: string): any;
/** Count the number of values in this column. */
export declare function count(column: string): Expr;
export declare function count(column: Series): number;
/** Compute the covariance between two columns/ expressions. */
export declare function cov(a: ExprOrString, b: ExprOrString): Expr;
/**
 * Exclude certain columns from a wildcard expression.
 *
 * Syntactic sugar for:
 * ```
 * >>> pl.col("*").exclude(columns)
 * ```
 */
export declare function exclude(columns: string[] | string): Expr;
export declare function exclude(col: string, ...cols: string[]): Expr;
/** Get the first value. */
export declare function first(column: string): Expr;
export declare function first<T>(column: Series): T;
/**
 * String format utility for expressions
 * Note: strings will be interpolated as `col(<value>)`. if you want a literal string, use `lit(<value>)`
 * @example
 * ```
 * >>> df = pl.DataFrame({
 * ...   "a": ["a", "b", "c"],
 * ...   "b": [1, 2, 3],
 * ... })
 * >>> df.select(
 * ...   pl.format("foo_{}_bar_{}", pl.col("a"), "b").alias("fmt"),
 * ... )
 * shape: (3, 1)
 * ┌─────────────┐
 * │ fmt         │
 * │ ---         │
 * │ str         │
 * ╞═════════════╡
 * │ foo_a_bar_1 │
 * ├╌╌╌╌╌╌╌╌╌╌╌╌╌┤
 * │ foo_b_bar_2 │
 * ├╌╌╌╌╌╌╌╌╌╌╌╌╌┤
 * │ foo_c_bar_3 │
 * └─────────────┘
 *
 * // You can use format as tag function as well
 * >>> pl.format("foo_{}_bar_{}", pl.col("a"), "b") // is the same as
 * >>> pl.format`foo_${pl.col("a")}_bar_${"b"}`
 * ```
 */
export declare function format(strings: string | TemplateStringsArray, ...expr: ExprOrString[]): Expr;
/** Syntactic sugar for `pl.col(column).aggGroups()` */
export declare function groups(column: string): Expr;
/** Get the first n rows of an Expression. */
export declare function head(column: ExprOrString, n?: number): Expr;
export declare function head(column: Series, n?: number): Series;
/** Get the last value. */
export declare function last(column: ExprOrString | Series): any;
/** Get the mean value. */
export declare function mean(column: ExprOrString): Expr;
export declare function mean(column: Series): number;
/** Get the median value. */
export declare function median(column: ExprOrString): Expr;
export declare function median(column: Series): number;
/** Count unique values. */
export declare function nUnique(column: ExprOrString): Expr;
export declare function nUnique(column: Series): number;
/** Compute the pearson's correlation between two columns. */
export declare function pearsonCorr(a: ExprOrString, b: ExprOrString): Expr;
/** Get the quantile */
export declare function quantile(column: ExprOrString, q: number): Expr;
export declare function quantile(column: Series, q: number): number;
/**
 * __Run polars expressions without a context.__
 *
 * This is syntactic sugar for running `df.select` on an empty DataFrame.
 */
export declare function select(expr: ExprOrString, ...exprs: ExprOrString[]): DataFrame;
/** Compute the spearman rank correlation between two columns. */
export declare function spearmanRankCorr(a: ExprOrString, b: ExprOrString): Expr;
/** Get the last n rows of an Expression. */
export declare function tail(column: ExprOrString, n?: number): Expr;
export declare function tail(column: Series, n?: number): Series;
/** Syntactic sugar for `pl.col(column).list()` */
export declare function list(column: ExprOrString): Expr;
/**
    Collect several columns into a Series of dtype Struct
    Parameters
    ----------
    @param exprs
        Columns/Expressions to collect into a Struct
    @param eager
        Evaluate immediately

    Examples
    --------
    ```
    >>> pl.DataFrame(
    ...     {
    ...         "int": [1, 2],
    ...         "str": ["a", "b"],
    ...         "bool": [True, None],
    ...         "list": [[1, 2], [3]],
    ...     }
    ... ).select([pl.struct(pl.all()).alias("my_struct")])
    shape: (2, 1)
    ┌───────────────────────┐
    │ my_struct             │
    │ ---                   │
    │ struct{int, ... list} │
    ╞═══════════════════════╡
    │ {1,"a",true,[1, 2]}   │
    ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
    │ {2,"b",null,[3]}      │
    └───────────────────────┘

    // Only collect specific columns as a struct:
    >>> df = pl.DataFrame({
    ...   "a": [1, 2, 3, 4],
    ...   "b": ["one", "two", "three", "four"],
    ...   "c": [9, 8, 7, 6]
    ... })
    >>> df.withColumn(pl.struct(pl.col(["a", "b"])).alias("a_and_b"))
    shape: (4, 4)
    ┌─────┬───────┬─────┬───────────────────────────────┐
    │ a   ┆ b     ┆ c   ┆ a_and_b                       │
    │ --- ┆ ---   ┆ --- ┆ ---                           │
    │ i64 ┆ str   ┆ i64 ┆ struct[2]{'a': i64, 'b': str} │
    ╞═════╪═══════╪═════╪═══════════════════════════════╡
    │ 1   ┆ one   ┆ 9   ┆ {1,"one"}                     │
    ├╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
    │ 2   ┆ two   ┆ 8   ┆ {2,"two"}                     │
    ├╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
    │ 3   ┆ three ┆ 7   ┆ {3,"three"}                   │
    ├╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
    │ 4   ┆ four  ┆ 6   ┆ {4,"four"}                    │
    └─────┴───────┴─────┴───────────────────────────────┘
```
*/
export declare function struct(exprs: Series[]): Series;
export declare function struct(exprs: ExprOrString | ExprOrString[]): Expr;
/**
 * Alias for an element in evaluated in an `eval` expression.

 * @example
  *
  *  A horizontal rank computation by taking the elements of a list
  *
  *  >>> df = pl.DataFrame({"a": [1, 8, 3], "b": [4, 5, 2]})
  *  >>> df.withColumn(
  *  ...     pl.concatList(["a", "b"]).arr.eval(pl.element().rank()).alias("rank")
  *  ... )
  *  shape: (3, 3)
  *  ┌─────┬─────┬────────────┐
  *  │ a   ┆ b   ┆ rank       │
  *  │ --- ┆ --- ┆ ---        │
  *  │ i64 ┆ i64 ┆ list[f32]  │
  *  ╞═════╪═════╪════════════╡
  *  │ 1   ┆ 4   ┆ [1.0, 2.0] │
  *  ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
  *  │ 8   ┆ 5   ┆ [2.0, 1.0] │
  *  ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
  *  │ 3   ┆ 2   ┆ [2.0, 1.0] │
  *  └─────┴─────┴────────────┘
  *
  *  A mathematical operation on array elements
  *
  *  >>> df = pl.DataFrame({"a": [1, 8, 3], "b": [4, 5, 2]})
  *  >>> df.withColumn(
  *  ...     pl.concatList(["a", "b"]).arr.eval(pl.element() * 2).alias("a_b_doubled")
  *  ... )
  *  shape: (3, 3)
  *  ┌─────┬─────┬─────────────┐
  *  │ a   ┆ b   ┆ a_b_doubled │
  *  │ --- ┆ --- ┆ ---         │
  *  │ i64 ┆ i64 ┆ list[i64]   │
  *  ╞═════╪═════╪═════════════╡
  *  │ 1   ┆ 4   ┆ [2, 8]      │
  *  ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┤
  *  │ 8   ┆ 5   ┆ [16, 10]    │
  *  ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┤
  *  │ 3   ┆ 2   ┆ [6, 4]      │
  *  └─────┴─────┴─────────────┘
 */
export declare function element(): Expr;
