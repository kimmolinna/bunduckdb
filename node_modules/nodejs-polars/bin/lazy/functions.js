"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.element = exports.struct = exports.list = exports.tail = exports.spearmanRankCorr = exports.select = exports.quantile = exports.pearsonCorr = exports.nUnique = exports.median = exports.mean = exports.last = exports.head = exports.groups = exports.format = exports.first = exports.exclude = exports.cov = exports.count = exports.concatString = exports.concatList = exports.avg = exports.argSortBy = exports.all = exports.arange = exports.lit = exports.cols = exports.col = void 0;
const expr_1 = require("./expr");
const series_1 = require("../series/series");
const dataframe_1 = require("../dataframe");
const utils_1 = require("../utils");
const polars_internal_1 = __importDefault(require("../internals/polars_internal"));
/**
 * __A column in a DataFrame.__
 * Can be used to select:
 *   * a single column by name
 *   * all columns by using a wildcard `"*"`
 *   * column by regular expression if the regex starts with `^` and ends with `$`
 * @param col
 * @example
 * ```
 * >>> df = pl.DataFrame({
 * >>> "ham": [1, 2, 3],
 * >>> "hamburger": [11, 22, 33],
 * >>> "foo": [3, 2, 1]})
 * >>> df.select(col("foo"))
 * shape: (3, 1)
 * ╭─────╮
 * │ foo │
 * │ --- │
 * │ i64 │
 * ╞═════╡
 * │ 3   │
 * ├╌╌╌╌╌┤
 * │ 2   │
 * ├╌╌╌╌╌┤
 * │ 1   │
 * ╰─────╯
 * >>> df.select(col("*"))
 * shape: (3, 3)
 * ╭─────┬───────────┬─────╮
 * │ ham ┆ hamburger ┆ foo │
 * │ --- ┆ ---       ┆ --- │
 * │ i64 ┆ i64       ┆ i64 │
 * ╞═════╪═══════════╪═════╡
 * │ 1   ┆ 11        ┆ 3   │
 * ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
 * │ 2   ┆ 22        ┆ 2   │
 * ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
 * │ 3   ┆ 33        ┆ 1   │
 * ╰─────┴───────────┴─────╯
 * >>> df.select(col("^ham.*$"))
 * shape: (3, 2)
 * ╭─────┬───────────╮
 * │ ham ┆ hamburger │
 * │ --- ┆ ---       │
 * │ i64 ┆ i64       │
 * ╞═════╪═══════════╡
 * │ 1   ┆ 11        │
 * ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
 * │ 2   ┆ 22        │
 * ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
 * │ 3   ┆ 33        │
 * ╰─────┴───────────╯
 * >>> df.select(col("*").exclude("ham"))
 * shape: (3, 2)
 * ╭───────────┬─────╮
 * │ hamburger ┆ foo │
 * │ ---       ┆ --- │
 * │ i64       ┆ i64 │
 * ╞═══════════╪═════╡
 * │ 11        ┆ 3   │
 * ├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
 * │ 22        ┆ 2   │
 * ├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
 * │ 33        ┆ 1   │
 * ╰───────────┴─────╯
 * >>> df.select(col(["hamburger", "foo"])
 * shape: (3, 2)
 * ╭───────────┬─────╮
 * │ hamburger ┆ foo │
 * │ ---       ┆ --- │
 * │ i64       ┆ i64 │
 * ╞═══════════╪═════╡
 * │ 11        ┆ 3   │
 * ├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
 * │ 22        ┆ 2   │
 * ├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
 * │ 33        ┆ 1   │
 * ╰───────────┴─────╯
 * >>> df.select(col(pl.Series(["hamburger", "foo"]))
 * shape: (3, 2)
 * ╭───────────┬─────╮
 * │ hamburger ┆ foo │
 * │ ---       ┆ --- │
 * │ i64       ┆ i64 │
 * ╞═══════════╪═════╡
 * │ 11        ┆ 3   │
 * ├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
 * │ 22        ┆ 2   │
 * ├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
 * │ 33        ┆ 1   │
 * ╰───────────┴─────╯
 * ```
 */
function col(col) {
    if (series_1.Series.isSeries(col)) {
        col = col.toArray();
    }
    if (Array.isArray(col)) {
        return (0, expr_1._Expr)(polars_internal_1.default.cols(col));
    }
    else {
        return (0, expr_1._Expr)(polars_internal_1.default.col(col));
    }
}
exports.col = col;
function cols(...cols) {
    return col(cols.flat());
}
exports.cols = cols;
function lit(value) {
    if (Array.isArray(value)) {
        value = (0, series_1.Series)(value);
    }
    if (series_1.Series.isSeries(value)) {
        return (0, expr_1._Expr)(polars_internal_1.default.lit(value.inner()));
    }
    return (0, expr_1._Expr)(polars_internal_1.default.lit(value));
}
exports.lit = lit;
function arange(opts, high, step, eager) {
    if (typeof opts?.low === "number") {
        return arange(opts.low, opts.high, opts.step, opts.eager);
    }
    else {
        const low = (0, expr_1.exprToLitOrExpr)(opts, false);
        high = (0, expr_1.exprToLitOrExpr)(high, false);
        if (eager) {
            const df = (0, dataframe_1.DataFrame)({ "a": [1] });
            return df.select(arange(low, high, step).alias("arange")).getColumn("arange");
        }
        return (0, expr_1._Expr)(polars_internal_1.default.arange(low, high, step));
    }
}
exports.arange = arange;
/**  Alias for `pl.col("*")` */
function all() {
    return col("*");
}
exports.all = all;
/**
 * __Find the indexes that would sort the columns.__
 * ___
 * Argsort by multiple columns. The first column will be used for the ordering.
 * If there are duplicates in the first column, the second column will be used to determine the ordering
 * and so on.
 */
function argSortBy(exprs, reverse = false) {
    if (!Array.isArray(reverse)) {
        reverse = Array.from({ length: exprs.length }, () => reverse);
    }
    const by = (0, utils_1.selectionToExprList)(exprs);
    return (0, expr_1._Expr)(polars_internal_1.default.argsortBy(by, reverse));
}
exports.argSortBy = argSortBy;
function avg(column) {
    return mean(column);
}
exports.avg = avg;
function concatList(...exprs) {
    const items = (0, utils_1.selectionToExprList)(exprs, false);
    return expr_1.Expr(polars_internal_1.default.concatLst(items));
}
exports.concatList = concatList;
function concatString(opts, sep = ",") {
    if (opts?.exprs) {
        return concatString(opts.exprs, opts.sep);
    }
    const items = (0, utils_1.selectionToExprList)(opts, false);
    return expr_1.Expr(polars_internal_1.default.concatStr(items, sep));
}
exports.concatString = concatString;
function count(column) {
    if (series_1.Series.isSeries(column)) {
        return column.len();
    }
    else {
        return col(column).count();
    }
}
exports.count = count;
/** Compute the covariance between two columns/ expressions. */
function cov(a, b) {
    a = (0, expr_1.exprToLitOrExpr)(a, false);
    b = (0, expr_1.exprToLitOrExpr)(b, false);
    return (0, expr_1._Expr)(polars_internal_1.default.cov(a, b));
}
exports.cov = cov;
function exclude(...columns) {
    return col("*").exclude(columns);
}
exports.exclude = exclude;
function first(column) {
    if (series_1.Series.isSeries(column)) {
        if (column.length) {
            return column.get(0);
        }
        else {
            throw new RangeError("The series is empty, so no first value can be returned.");
        }
    }
    else {
        return col(column).first();
    }
}
exports.first = first;
/**
 * String format utility for expressions
 * Note: strings will be interpolated as `col(<value>)`. if you want a literal string, use `lit(<value>)`
 * @example
 * ```
 * >>> df = pl.DataFrame({
 * ...   "a": ["a", "b", "c"],
 * ...   "b": [1, 2, 3],
 * ... })
 * >>> df.select(
 * ...   pl.format("foo_{}_bar_{}", pl.col("a"), "b").alias("fmt"),
 * ... )
 * shape: (3, 1)
 * ┌─────────────┐
 * │ fmt         │
 * │ ---         │
 * │ str         │
 * ╞═════════════╡
 * │ foo_a_bar_1 │
 * ├╌╌╌╌╌╌╌╌╌╌╌╌╌┤
 * │ foo_b_bar_2 │
 * ├╌╌╌╌╌╌╌╌╌╌╌╌╌┤
 * │ foo_c_bar_3 │
 * └─────────────┘
 *
 * // You can use format as tag function as well
 * >>> pl.format("foo_{}_bar_{}", pl.col("a"), "b") // is the same as
 * >>> pl.format`foo_${pl.col("a")}_bar_${"b"}`
 * ```
 */
function format(strings, ...expr) {
    if (typeof strings === "string") {
        const s = strings.split("{}");
        if (s.length - 1 !== expr.length) {
            throw new RangeError("number of placeholders should equal the number of arguments");
        }
        return format(s, ...expr);
    }
    const d = (0, utils_1.range)(0, Math.max(strings.length, expr.length))
        .flatMap((i) => {
        const sVal = strings[i] ? lit(strings[i]) : [];
        const exprVal = expr[i] ? (0, expr_1.exprToLitOrExpr)(expr[i], false) : [];
        return [sVal, exprVal];
    })
        .flat();
    return concatString(d, "");
}
exports.format = format;
/** Syntactic sugar for `pl.col(column).aggGroups()` */
function groups(column) {
    return col(column).aggGroups();
}
exports.groups = groups;
function head(column, n) {
    if (series_1.Series.isSeries(column)) {
        return column.head(n);
    }
    else {
        return (0, expr_1.exprToLitOrExpr)(column, false).head(n);
    }
}
exports.head = head;
/** Get the last value. */
function last(column) {
    if (series_1.Series.isSeries(column)) {
        if (column.length) {
            return column.get(-1);
        }
        else {
            throw new RangeError("The series is empty, so no last value can be returned.");
        }
    }
    else {
        return (0, expr_1.exprToLitOrExpr)(column, false).last();
    }
}
exports.last = last;
function mean(column) {
    if (series_1.Series.isSeries(column)) {
        return column.mean();
    }
    return (0, expr_1.exprToLitOrExpr)(column, false).mean();
}
exports.mean = mean;
function median(column) {
    if (series_1.Series.isSeries(column)) {
        return column.median();
    }
    return (0, expr_1.exprToLitOrExpr)(column, false).median();
}
exports.median = median;
function nUnique(column) {
    if (series_1.Series.isSeries(column)) {
        return column.nUnique();
    }
    return (0, expr_1.exprToLitOrExpr)(column, false).nUnique();
}
exports.nUnique = nUnique;
/** Compute the pearson's correlation between two columns. */
function pearsonCorr(a, b) {
    a = (0, expr_1.exprToLitOrExpr)(a, false);
    b = (0, expr_1.exprToLitOrExpr)(b, false);
    return (0, expr_1._Expr)(polars_internal_1.default.pearsonCorr(a, b));
}
exports.pearsonCorr = pearsonCorr;
function quantile(column, q) {
    if (series_1.Series.isSeries(column)) {
        return column.quantile(q);
    }
    return (0, expr_1.exprToLitOrExpr)(column, false).quantile(q);
}
exports.quantile = quantile;
/**
 * __Run polars expressions without a context.__
 *
 * This is syntactic sugar for running `df.select` on an empty DataFrame.
 */
function select(expr, ...exprs) {
    return (0, dataframe_1.DataFrame)({}).select(expr, ...exprs);
}
exports.select = select;
/** Compute the spearman rank correlation between two columns. */
function spearmanRankCorr(a, b) {
    a = (0, expr_1.exprToLitOrExpr)(a, false);
    b = (0, expr_1.exprToLitOrExpr)(b, false);
    return (0, expr_1._Expr)(polars_internal_1.default.spearmanRankCorr(a, b, null, false));
}
exports.spearmanRankCorr = spearmanRankCorr;
function tail(column, n) {
    if (series_1.Series.isSeries(column)) {
        return column.tail(n);
    }
    else {
        return (0, expr_1.exprToLitOrExpr)(column, false).tail(n);
    }
}
exports.tail = tail;
/** Syntactic sugar for `pl.col(column).list()` */
function list(column) {
    return (0, expr_1.exprToLitOrExpr)(column, false).list();
}
exports.list = list;
function struct(exprs) {
    exprs = Array.isArray(exprs) ? exprs : [exprs];
    if (series_1.Series.isSeries(exprs[0])) {
        return select((0, expr_1._Expr)(polars_internal_1.default.asStruct(exprs.map(e => polars_internal_1.default.lit(e.inner()))))).toSeries();
    }
    exprs = (0, utils_1.selectionToExprList)(exprs);
    return (0, expr_1._Expr)(polars_internal_1.default.asStruct(exprs));
}
exports.struct = struct;
/**
 * Alias for an element in evaluated in an `eval` expression.

 * @example
  *
  *  A horizontal rank computation by taking the elements of a list
  *
  *  >>> df = pl.DataFrame({"a": [1, 8, 3], "b": [4, 5, 2]})
  *  >>> df.withColumn(
  *  ...     pl.concatList(["a", "b"]).arr.eval(pl.element().rank()).alias("rank")
  *  ... )
  *  shape: (3, 3)
  *  ┌─────┬─────┬────────────┐
  *  │ a   ┆ b   ┆ rank       │
  *  │ --- ┆ --- ┆ ---        │
  *  │ i64 ┆ i64 ┆ list[f32]  │
  *  ╞═════╪═════╪════════════╡
  *  │ 1   ┆ 4   ┆ [1.0, 2.0] │
  *  ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
  *  │ 8   ┆ 5   ┆ [2.0, 1.0] │
  *  ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
  *  │ 3   ┆ 2   ┆ [2.0, 1.0] │
  *  └─────┴─────┴────────────┘
  *
  *  A mathematical operation on array elements
  *
  *  >>> df = pl.DataFrame({"a": [1, 8, 3], "b": [4, 5, 2]})
  *  >>> df.withColumn(
  *  ...     pl.concatList(["a", "b"]).arr.eval(pl.element() * 2).alias("a_b_doubled")
  *  ... )
  *  shape: (3, 3)
  *  ┌─────┬─────┬─────────────┐
  *  │ a   ┆ b   ┆ a_b_doubled │
  *  │ --- ┆ --- ┆ ---         │
  *  │ i64 ┆ i64 ┆ list[i64]   │
  *  ╞═════╪═════╪═════════════╡
  *  │ 1   ┆ 4   ┆ [2, 8]      │
  *  ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┤
  *  │ 8   ┆ 5   ┆ [16, 10]    │
  *  ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┤
  *  │ 3   ┆ 2   ┆ [6, 4]      │
  *  └─────┴─────┴─────────────┘
 */
function element() {
    return col("");
}
exports.element = element;
// // export function collect_all() {}
// // export function all() {} // fold
// // export function any() {} // fold
// // export function apply() {} // lambda
// // export function fold() {}
// // export function map_binary() {} //lambda
// // export function map() {} //lambda
// // export function max() {} // fold
// // export function min() {} // fold
// // export function sum() {} // fold
