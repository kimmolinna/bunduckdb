"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringFunctions = void 0;
const series_1 = require("./series");
const utils_1 = require("../utils");
const functions_1 = require("../lazy/functions");
const StringFunctions = (_s) => {
    const wrap = (method, ...args) => {
        const ret = _s[method](...args);
        return (0, series_1._Series)(ret);
    };
    const handleDecode = (encoding, strict) => {
        switch (encoding) {
            case "hex":
                return wrap("strHexDecode", strict);
            case "base64":
                return wrap("strBase64Decode", strict);
            default:
                throw new RangeError("supported encodings are 'hex' and 'base64'");
        }
    };
    return {
        concat(delimiter) {
            return (0, series_1._Series)(_s)
                .toFrame()
                .select((0, functions_1.col)(_s.name)
                .str
                .concat(delimiter)
                .as(_s.name))
                .getColumn(_s.name);
        },
        contains(pat) {
            return wrap("strContains", (0, utils_1.regexToString)(pat));
        },
        decode(arg, strict = false) {
            if (typeof arg === "string") {
                return handleDecode(arg, strict);
            }
            return handleDecode(arg.encoding, arg.strict);
        },
        encode(encoding) {
            switch (encoding) {
                case "hex":
                    return wrap(`strHexEncode`);
                case "base64":
                    return wrap(`strBase64Encode`);
                default:
                    throw new RangeError("supported encodings are 'hex' and 'base64'");
            }
        },
        extract(pat, groupIndex) {
            return wrap("strExtract", (0, utils_1.regexToString)(pat), groupIndex);
        },
        jsonPathMatch(pat) {
            return wrap("strJsonPathMatch", pat);
        },
        lengths() {
            return wrap("strLengths");
        },
        lstrip() {
            return wrap("strReplace", /^\s*/.source, "");
        },
        replace(pat, val) {
            return wrap("strReplace", (0, utils_1.regexToString)(pat), val);
        },
        replaceAll(pat, val) {
            return wrap("strReplaceAll", (0, utils_1.regexToString)(pat), val);
        },
        rstrip() {
            return wrap("strReplace", /[ \t]+$/.source, "");
        },
        slice(start, length) {
            return wrap("strSlice", start, length);
        },
        split(by, options) {
            const inclusive = typeof options === "boolean" ? options : options?.inclusive;
            const s = (0, series_1._Series)(_s);
            return s
                .toFrame()
                .select((0, functions_1.col)(s.name)
                .str
                .split(by, inclusive)
                .as(s.name))
                .getColumn(s.name);
        },
        strip() {
            const s = (0, series_1._Series)(_s);
            return s
                .toFrame()
                .select((0, functions_1.col)(s.name)
                .str
                .strip()
                .as(s.name))
                .getColumn(s.name);
        },
        strptime(dtype, fmt) {
            const s = (0, series_1._Series)(_s);
            return s
                .toFrame()
                .select((0, functions_1.col)(s.name)
                .str
                .strptime(dtype, fmt)
                .as(s.name))
                .getColumn(s.name);
        },
        toLowerCase() {
            return wrap("strToLowercase");
        },
        toUpperCase() {
            return wrap("strToUppercase");
        },
    };
};
exports.StringFunctions = StringFunctions;
